import { AnySymbol } from "../Symbols/AllSymbols";
import { AnyType } from "../Symbols/AnyType";
import { LiteralTypeStringLiteral } from "../Symbols/Literal";

function getTypeIdentifierWriting(type: AnyType): string {
    switch (type.kind) {
        case 'number':
            return 'Double'
        case 'string':
            return 'String'
        case 'typeref':
            return type.identifier
        case 'stringliteral':
            return `"${type.literal}" /* what else did you want? */`
        case 'array':
            return `Array<${getTypeIdentifierWriting(type.elementType)}>`
        case 'void':
            return 'Unit'
        case 'union':
            return type.unionDeclaration.typesOfUnion.map(type => getTypeIdentifierWriting(type)).join(' | ')
    }
}

function generateHeader(shouldImportSerialization: boolean): string {
    let txt = ''
    function text(str: string) { txt += str }
    function line(str: string|undefined = undefined) { if (str) { txt += `${str}\n` } else { txt += '\n' } }


    line('// THIS FILE IS AUTOGENERATED VIA ts-cross-mobile. DO NOT EDIT.')
    line()
    if (shouldImportSerialization) {
        line('import kotlinx.serialization.SerialName')
        line('import kotlinx.serialization.Serializable')
        line()
    }
    
    return txt
}

function getCanonicalEnumCaseName(originalCaseName: string): string {
    const value = originalCaseName
    if (value.length == 0) {
        return ''
    }
    let canonicalKotlinName = ''

    const firstChar = value.charAt(0)
    const firstCharUppercased = firstChar.toUpperCase()
    const firstCharIsUppercase = firstChar == firstCharUppercased

    canonicalKotlinName += firstCharUppercased

    function undersored(char: string) { canonicalKotlinName += `_${char}` }
    function raw(char: string) { canonicalKotlinName += char }


    let prevCharWasUppercase = firstCharIsUppercase
    let weInASequenceOf2UppercaseChars = false
    for (let x = 1, char = ''; char = value.charAt(x); x++) { 
        const charUppercased = char.toUpperCase()
        const thisCharIsUppercased = char == charUppercased


        const shouldUnderscore = weInASequenceOf2UppercaseChars && !thisCharIsUppercased
            || !prevCharWasUppercase && thisCharIsUppercased
        weInASequenceOf2UppercaseChars = weInASequenceOf2UppercaseChars && thisCharIsUppercased 
            || prevCharWasUppercase && thisCharIsUppercased

        
        if (shouldUnderscore) {
            undersored(charUppercased)
        } else {
            raw(charUppercased)
        }
        
        // if (weInASequenceOf2UppercaseChars) {
        //     if (thisCharIsUppercased) {
        //         weInASequenceOf2UppercaseChars = true
        //         raw(charUppercased)
        //     } else {
        //         weInASequenceOf2UppercaseChars = false
        //         undersored(charUppercased)
        //     }
        // } else {
        //     if (prevCharWasUppercase && thisCharIsUppercased) {
        //         weInASequenceOf2UppercaseChars = true
        //         raw(charUppercased)
        //     } else if (!prevCharWasUppercase && thisCharIsUppercased) {
        //         weInASequenceOf2UppercaseChars = false
        //         undersored(charUppercased)
        //     } else if (prevCharWasUppercase && !thisCharIsUppercased) {
        //         weInASequenceOf2UppercaseChars = false
        //         raw(charUppercased)
        //     } else {
        //         weInASequenceOf2UppercaseChars = false
        //         raw(charUppercased)
        //     }
        // }

        prevCharWasUppercase = thisCharIsUppercased
    }

    return canonicalKotlinName
}

function generateSymbol(symbol: AnySymbol): string|undefined {
    let txt = ''
    function text(str: string) { txt += str }
    function line(str: string|undefined = undefined) { if (str) { txt += `${str}\n` } else { txt += '\n' } }

    switch (symbol.kind) {
        case 'interface':
            const interfaceDeclaration = symbol.interfaceDecl

            if (symbol.generationOptions.shouldGenerateJsonSerialization) {
                line('@Serializable')
            }
            line(`data class ${interfaceDeclaration.identifier}(`)

            for (const prop of interfaceDeclaration.props) {
                function declarePropertyOfType(type: string) {
                    line(`    val ${prop.identifer}: ${type}`)
                }

                function declareStringParamWithDefaultValue(valueLiteral: string) {
                    line(`    val ${prop.identifer} = "${valueLiteral}"`)
                }

                if (prop.type.kind == 'stringliteral') {
                    declareStringParamWithDefaultValue(prop.type.literal)
                    continue
                }

                const typeWriting = getTypeIdentifierWriting(prop.type)

                declarePropertyOfType(typeWriting)
            }

            line(')')
            line()

            break
        case 'typealias':
            const typealias = symbol.typealiasDecl

            switch (typealias.type.kind) {
            case 'union':
                const allTypesAreString = typealias.type.unionDeclaration.typesOfUnion.every(type => {
                    return type.kind == 'stringliteral'
                })

                if (allTypesAreString) {
                    // Good, means I can generate an enum

                    if (symbol.generationOptions.shouldGenerateJsonSerialization) {
                        line('@Serializable')
                    }
                    line(`enum class ${typealias.id} {`)

                    for (const [index, type] of typealias.type.unionDeclaration.typesOfUnion.entries()) {
                        const value = (type as LiteralTypeStringLiteral).literal
                        const canonicalCaseName = getCanonicalEnumCaseName(value)

                        if (symbol.generationOptions.shouldGenerateJsonSerialization) {
                            line(`    @SerialName("${value}")`)
                        }
                        line(`    ${canonicalCaseName},`)

                        const shouldAddEmptyLineAfterThisCase = symbol.generationOptions.shouldGenerateJsonSerialization
                            && index < typealias.type.unionDeclaration.typesOfUnion.length - 1 // i.e. not last

                        if (shouldAddEmptyLineAfterThisCase) {
                            line()
                        }
                    }

                    line(`}`)
                    line()

                    break
                }

                // unsupported
                
                break
            default:
                // unsupported
                break
            }

            break
        }

    return txt.length > 0 ? txt : undefined
}


export function generateKotlinFileForAllSymbols(symbols: AnySymbol[]): string {
    let file = ''

    let symbolTexts: string[] = []

    let thereWereSymbolsThatNeedSerialization = false
    for (const symbol of symbols) {
        if (!symbol.generationOptions.shouldGenerate) {
            continue
        }

        const generatedText = generateSymbol(symbol)
        if (generatedText) {
            if (symbol.generationOptions.shouldGenerateJsonSerialization) {
                thereWereSymbolsThatNeedSerialization = true
            }
            symbolTexts.push(generatedText)
        }
    }

    function text(str: string) { file += str }

    text(generateHeader(thereWereSymbolsThatNeedSerialization))

    for (const symbolText of symbolTexts) {
        text(symbolText)
    }

    return file
}
