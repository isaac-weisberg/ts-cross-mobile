import { AnySymbol } from "../Symbols/AllSymbols";
import { AnyType } from "../Symbols/AnyType";
import { LiteralTypeStringLiteral } from "../Symbols/Literal";

function getTypeIdentifierWriting(type: AnyType): string {
    switch (type.kind) {
        case 'number':
            return 'Double'
        case 'string':
            return 'String'
        case 'typeref':
            return type.identifier
        case 'stringliteral':
            return `"${type.literal}" /* what else did you want? */`
        case 'array':
            return `[${getTypeIdentifierWriting(type.elementType)}]`
        case 'void':
            return 'Void'
        case 'union':
            return type.unionDeclaration.typesOfUnion.map(type => getTypeIdentifierWriting(type)).join(' | ')
    }
}

export function generateSwiftFileForAllSymbols(symbols: AnySymbol[]): string {
    let file = ''

    function text(str: string) { file += str }
    function line(str: string|undefined = undefined) { if (str) { file += `${str}\n` } else { file += '\n' } }

    line('// swiftlint:disable all')
    line('// THIS FILE IS AUTOGENERATED VIA ts-cross-mobile. DO NOT EDIT.')
    line()

    for (const symbol of symbols) {
        if (!symbol.generationOptions.shouldGenerate) {
            continue
        }

        switch (symbol.kind) {
        case 'interface':
            const interfaceDeclaration = symbol.interfaceDecl

            if (symbol.generationOptions.shouldGenerateJsonSerialization) {
                line(`struct ${interfaceDeclaration.identifier}: Codable {`)
            } else {
                line(`struct ${interfaceDeclaration.identifier} {`)
            }

            for (const prop of interfaceDeclaration.props) {
                function declarePropertyOfType(type: string) {
                    line(`    let ${prop.identifer}: ${type}`)
                }

                function declareConstantString(valueLiteral: string) {
                    line(`    let ${prop.identifer} = "${valueLiteral}"`)
                }
                
                if (prop.type.kind == 'stringliteral') {
                    declareConstantString(prop.type.literal)
                    continue
                }

                const typeWriting = getTypeIdentifierWriting(prop.type)
                declarePropertyOfType(typeWriting)
            }

            line('}')
            line()

            break
        case 'typealias':
            const typealias = symbol.typealiasDecl

            switch (typealias.type.kind) {
            case 'union':
                const allTypesAreString = typealias.type.unionDeclaration.typesOfUnion.every(type => {
                    return type.kind == 'stringliteral'
                })

                if (allTypesAreString) {
                    // Good, means I can generate an enum

                    if (symbol.generationOptions.shouldGenerateJsonSerialization) {
                        line(`enum ${typealias.id}: String, Codable {`)
                    } else {
                        line(`enum ${typealias.id} {`)
                    }

                    
                    for (const type of typealias.type.unionDeclaration.typesOfUnion) {
                        const value = (type as LiteralTypeStringLiteral).literal

                        line(`    case ${value}`)
                    }

                    line(`}`)
                    line()

                    break
                }

                // unsupported
                
                break
            default:
                // unsupported
                break
            }

            break
        }
    }

    return file
}